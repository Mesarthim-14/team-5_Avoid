//=============================================================================
//
// エッジシェーダ [EdgeFillter1.fx]
// Author : Konishi Yuuto
//
//=============================================================================

//=============================================================================
// グローバル変数宣言
//=============================================================================
float2   m_Texel;                 //１テクセルのサイズ
float    m_Limit;                 //エッジとなるかを判定するための基準値。1.0fでエッジフィルターが無効になる。

//=============================================================================
// テクスチャ情報
//=============================================================================
sampler tex0 : register(s0);      //シーンのカラー情報を格納したテクスチャー
sampler tex1 : register(s1);      //シーンのZ値を格納したテクスチャー

//=============================================================================
// 構造体
//=============================================================================
struct VS_OUTPUT
{
	float4 Pos : POSITION;
	float2 Tex : TEXCOORD0;
};

//=============================================================================
// 頂点シェーダ
//=============================================================================
VS_OUTPUT VS(float4 Pos : POSITION, float4 Col : COLOR0, float2 Tex : TEXCOORD0)
{
	VS_OUTPUT Out;
	
	Out.Pos = Pos;
	Out.Tex = Tex;
	
	return Out;
}

//=============================================================================
// ピクセルシェーダ
//=============================================================================
float4 PS(VS_OUTPUT In) : COLOR0
{
	float4 Col = float4(0.0f, 0.0f, 0.0f, 1.0f);
	
	// Ｚ値情報で書き込んであるテクスチャーを参照し、現在のピクセル位置のＺ値を取得
	float Z1 = tex2D( tex1, In.Tex ).r;

	// 周辺のピクセル位置のＺ値を取得
	float Z2 = tex2D(tex1, clamp( In.Tex + float2(  m_Texel.x,  m_Texel.y ), 0.0f, 1.0f ) ).r;
	float Z3 = tex2D(tex1, clamp( In.Tex + float2(  m_Texel.x, -m_Texel.y ), 0.0f, 1.0f ) ).r;
	float Z4 = tex2D(tex1, clamp( In.Tex + float2( -m_Texel.x,  m_Texel.y ), 0.0f, 1.0f ) ).r;
	float Z5 = tex2D(tex1, clamp( In.Tex + float2( -m_Texel.x, -m_Texel.y ), 0.0f, 1.0f ) ).r;

	// 周辺のピクセル位置のＺ値と比較し、m_Limitより大きいところがあったらエッジ部分と判定する
	if (abs(Z1 - Z2) < m_Limit*0.1f &&
		abs(Z1 - Z3) < m_Limit*0.1f &&
		abs(Z1 - Z4) < m_Limit*0.1f &&
		abs(Z1 - Z5) < m_Limit*0.1f)
	{
		Col = tex2D(tex0, In.Tex);
	}
	
	return Col;
}

//=============================================================================
// テクニック
//=============================================================================
technique TShader
{
	pass P0
	{
		VertexShader = compile vs_1_1 VS();
		PixelShader = compile ps_2_0 PS();
	}
}